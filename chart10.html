<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flow Curves - Organic Motion</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #1e3c72 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .chart-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            background: transparent;
            border-radius: 0;
            padding: 0;
            box-shadow: none;
            backdrop-filter: none;
        }

        canvas {
            width: 100%;
            height: 100%;
            border-radius: 0;
        }

        .back-link {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.25);
            display: flex;
            align-items: center;
            justify-content: center;
            text-decoration: none;
            border-radius: 50%;
            transition: all 0.3s;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            z-index: 10;
        }

        .back-link:hover {
            background: rgba(255, 255, 255, 0.35);
            transform: translateY(-3px);
        }

        .back-link svg {
            width: 24px;
            height: 24px;
            fill: white;
        }

        @media (max-width: 768px) {
            .back-link {
                bottom: 20px;
                left: 20px;
                width: 45px;
                height: 45px;
            }
            .back-link svg {
                width: 20px;
                height: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="chart-container">

        <canvas id="chart"></canvas>
    </div>

    <a href="index.html" class="back-link">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M3 9l9-7 9 7v11a2 2 0 01-2 2H5a2 2 0 01-2-2z"/>
            <polyline points="9 22 9 12 15 12 15 22"/>
        </svg>
        
    </a>

    <script>
        const canvas = document.getElementById('chart');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = canvas.offsetWidth * window.devicePixelRatio;
            canvas.height = canvas.offsetHeight * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        class FlowCurve {
            constructor(y, amplitude, frequency, speed, hue, width) {
                this.baseY = y;
                this.amplitude = amplitude;
                this.frequency = frequency;
                this.speed = speed;
                this.hue = hue;
                this.offset = Math.random() * Math.PI * 2;
                this.points = [];
                this.width = width;
                this.initPoints();
            }

            initPoints() {
                const numPoints = 100;
                for (let i = 0; i <= numPoints; i++) {
                    this.points.push({
                        x: (this.width / numPoints) * i,
                        y: 0
                    });
                }
            }

            update(time) {
                this.points.forEach((point, index) => {
                    const x = point.x;
                    const wave1 = Math.sin(x * this.frequency + time * this.speed + this.offset) * this.amplitude;
                    const wave2 = Math.sin(x * this.frequency * 0.5 + time * this.speed * 0.7) * (this.amplitude * 0.5);
                    point.y = this.baseY + wave1 + wave2;
                });
            }

            draw(ctx) {
                // Draw gradient fill
                const gradient = ctx.createLinearGradient(0, this.baseY - this.amplitude * 2, 0, this.baseY + this.amplitude * 2);
                gradient.addColorStop(0, `hsla(${this.hue}, 100%, 70%, 0.15)`);
                gradient.addColorStop(0.5, `hsla(${this.hue}, 100%, 60%, 0.25)`);
                gradient.addColorStop(1, `hsla(${this.hue}, 100%, 50%, 0.1)`);

                ctx.beginPath();
                ctx.moveTo(this.points[0].x, this.points[0].y);

                for (let i = 1; i < this.points.length; i++) {
                    const prev = this.points[i - 1];
                    const curr = this.points[i];
                    const cpX = (prev.x + curr.x) / 2;
                    const cpY = (prev.y + curr.y) / 2;
                    ctx.quadraticCurveTo(prev.x, prev.y, cpX, cpY);
                }

                const lastPoint = this.points[this.points.length - 1];
                ctx.lineTo(lastPoint.x, lastPoint.y);
                ctx.lineTo(this.width, this.baseY + this.amplitude * 3);
                ctx.lineTo(0, this.baseY + this.amplitude * 3);
                ctx.closePath();

                ctx.fillStyle = gradient;
                ctx.fill();

                // Draw line
                const lineGradient = ctx.createLinearGradient(0, 0, this.width, 0);
                lineGradient.addColorStop(0, `hsla(${this.hue}, 100%, 70%, 0.8)`);
                lineGradient.addColorStop(0.5, `hsla(${this.hue}, 100%, 80%, 1)`);
                lineGradient.addColorStop(1, `hsla(${this.hue}, 100%, 70%, 0.8)`);

                ctx.beginPath();
                ctx.moveTo(this.points[0].x, this.points[0].y);

                for (let i = 1; i < this.points.length; i++) {
                    const prev = this.points[i - 1];
                    const curr = this.points[i];
                    const cpX = (prev.x + curr.x) / 2;
                    const cpY = (prev.y + curr.y) / 2;
                    ctx.quadraticCurveTo(prev.x, prev.y, cpX, cpY);
                }

                ctx.strokeStyle = lineGradient;
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.stroke();

                // Draw glow
                ctx.beginPath();
                ctx.moveTo(this.points[0].x, this.points[0].y);

                for (let i = 1; i < this.points.length; i++) {
                    const prev = this.points[i - 1];
                    const curr = this.points[i];
                    const cpX = (prev.x + curr.x) / 2;
                    const cpY = (prev.y + curr.y) / 2;
                    ctx.quadraticCurveTo(prev.x, prev.y, cpX, cpY);
                }

                ctx.shadowColor = `hsl(${this.hue}, 100%, 70%)`;
                ctx.shadowBlur = 20;
                ctx.strokeStyle = lineGradient;
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.shadowBlur = 0;

                // Draw particles along curve
                for (let i = 0; i < this.points.length; i += 10) {
                    const point = this.points[i];
                    const size = 3 + Math.sin((i + Date.now() / 200) * 0.1) * 2;

                    const particleGradient = ctx.createRadialGradient(point.x, point.y, 0, point.x, point.y, size * 3);
                    particleGradient.addColorStop(0, `hsla(${this.hue}, 100%, 90%, 0.8)`);
                    particleGradient.addColorStop(1, `hsla(${this.hue}, 100%, 70%, 0)`);

                    ctx.beginPath();
                    ctx.arc(point.x, point.y, size * 3, 0, Math.PI * 2);
                    ctx.fillStyle = particleGradient;
                    ctx.fill();
                }
            }
        }

        let time = 0;
        let curves = [];

        function initCurves() {
            const width = canvas.offsetWidth;
            const height = canvas.offsetHeight;

            curves = [
                new FlowCurve(height * 0.25, 50, 0.01, 0.02, 200, width),
                new FlowCurve(height * 0.4, 60, 0.015, 0.025, 240, width),
                new FlowCurve(height * 0.55, 45, 0.012, 0.018, 280, width),
                new FlowCurve(height * 0.7, 55, 0.018, 0.022, 320, width),
                new FlowCurve(height * 0.85, 40, 0.02, 0.03, 180, width)
            ];
        }

        function drawChart() {
            const width = canvas.offsetWidth;
            const height = canvas.offsetHeight;

            // Clear with fade
            ctx.fillStyle = 'rgba(10, 14, 39, 0.15)';
            ctx.fillRect(0, 0, width, height);

            // Update and draw curves
            curves.forEach(curve => {
                curve.update(time);
                curve.draw(ctx);
            });

            time += 0.01;
            requestAnimationFrame(drawChart);
        }

        // Initial setup
        ctx.fillStyle = 'rgba(10, 14, 39, 1)';
        ctx.fillRect(0, 0, canvas.offsetWidth, canvas.offsetHeight);

        initCurves();
        drawChart();

        window.addEventListener('resize', () => {
            resizeCanvas();
            initCurves();
        });
    </script>
</body>
</html>
